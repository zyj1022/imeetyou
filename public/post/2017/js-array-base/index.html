<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Javascript基础之数组 - 知也无涯</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="ZHIKING" /><meta name="description" content="简介 数组是编程语言中应用最广泛的存储结构，在 ECMAScript 中数组是非常常用的引用类型。很有必要将数组的内容捋一遍，加深印象。 数组属性 constructor 表示引用数组对象的" /><meta name="keywords" content="Hugo, blog, 智的博客" />






<meta name="generator" content="Hugo 0.69.0 with theme even" />


<link rel="canonical" href="/post/2017/js-array-base/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.78f8f17bab244b9ee62ad16480c9584d5fc2db06ae20681d1ca225cefd80767c.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Javascript基础之数组" />
<meta property="og:description" content="简介 数组是编程语言中应用最广泛的存储结构，在 ECMAScript 中数组是非常常用的引用类型。很有必要将数组的内容捋一遍，加深印象。 数组属性 constructor 表示引用数组对象的" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/2017/js-array-base/" />
<meta property="article:published_time" content="2017-03-22T11:34:42+00:00" />
<meta property="article:modified_time" content="2017-03-22T11:34:42+00:00" />
<meta itemprop="name" content="Javascript基础之数组">
<meta itemprop="description" content="简介 数组是编程语言中应用最广泛的存储结构，在 ECMAScript 中数组是非常常用的引用类型。很有必要将数组的内容捋一遍，加深印象。 数组属性 constructor 表示引用数组对象的">
<meta itemprop="datePublished" content="2017-03-22T11:34:42&#43;00:00" />
<meta itemprop="dateModified" content="2017-03-22T11:34:42&#43;00:00" />
<meta itemprop="wordCount" content="5259">



<meta itemprop="keywords" content="js,frontend,array," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Javascript基础之数组"/>
<meta name="twitter:description" content="简介 数组是编程语言中应用最广泛的存储结构，在 ECMAScript 中数组是非常常用的引用类型。很有必要将数组的内容捋一遍，加深印象。 数组属性 constructor 表示引用数组对象的"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">知也无涯</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">知也无涯</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Javascript基础之数组</h1>

      <div class="post-meta">
        <span class="post-time"> 2017-03-22 </span>
        <div class="post-category">
            <a href="/categories/frontend/"> frontend </a>
            </div>
          <span class="more-meta"> 约 5259 字 </span>
          <span class="more-meta"> 预计阅读 11 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#简介">简介</a></li>
    <li><a href="#数组属性">数组属性</a></li>
    <li><a href="#基本操作">基本操作</a>
      <ul>
        <li><a href="#一创建方法">一、创建方法</a></li>
        <li><a href="#二检测方法">二、检测方法</a></li>
      </ul>
    </li>
    <li><a href="#ecm3方法">ECM3方法</a>
      <ul>
        <li><a href="#1arrayprototypejoin">1、Array.prototype.join()</a></li>
        <li><a href="#2arrayprototypepush">2、Array.prototype.push()</a></li>
        <li><a href="#3arrayprototypepop">3、Array.prototype.pop()</a></li>
        <li><a href="#4arrayprototypeunshift">4、Array.prototype.unshift()</a></li>
        <li><a href="#5arrayprototypeshift">5、Array.prototype.shift()</a></li>
        <li><a href="#6arrayprototypesort">6、Array.prototype.sort()</a></li>
        <li><a href="#7arrayprototypereverse">7、Array.prototype.reverse()</a></li>
        <li><a href="#8arrayprototypeconcat">8、Array.prototype.concat()</a></li>
        <li><a href="#9arrayprototypeslice">9、Array.prototype.slice()</a></li>
        <li><a href="#10arrayprototypesplice">10、Array.prototype.splice()</a></li>
      </ul>
    </li>
    <li><a href="#ecm5方法">ECM5方法</a>
      <ul>
        <li><a href="#1arrayprototypeindexof">1、Array.prototype.indexOf()</a></li>
        <li><a href="#2arrayprototypelastindexof">2、Array.prototype.lastIndexOf()</a></li>
        <li><a href="#3arrayprototypeevery">3、Array.prototype.every()</a></li>
        <li><a href="#4arrayprototypesome">4、Array.prototype.some()</a></li>
        <li><a href="#5arrayprototypefilter">5、Array.prototype.filter()</a></li>
        <li><a href="#6arrayprototypemap">6、Array.prototype.map()</a></li>
        <li><a href="#7arrayprototypeforeach">7、Array.prototype.forEach()</a></li>
        <li><a href="#8arrayprototypereduce">8、Array.prototype.reduce()</a></li>
        <li><a href="#9arrayprototypereduceright">9、Array.prototype.reduceRight()</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="简介">简介</h2>
<p>数组是编程语言中应用最广泛的存储结构，在 ECMAScript 中数组是非常常用的引用类型。很有必要将数组的内容捋一遍，加深印象。</p>
<h2 id="数组属性">数组属性</h2>
<ul>
<li>constructor 表示引用数组对象的构造函数</li>
<li>length 表示数组的长度，即其中元素的个数。注意在js中length属性是可变的，当设置一个数组的length值变大时，数组内容不会改变，仅仅是length更改，但当length设置小于实际数组的时候，则原数组中索引大于或等于length的元素的值全部被丢失。</li>
<li>prototype属性是object共有的，可以通过增加属性和方法扩展数组定义。</li>
</ul>
<h2 id="基本操作">基本操作</h2>
<h3 id="一创建方法">一、创建方法</h3>
<h4 id="创建一个空数组">创建一个空数组</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var arr = [];
var arr = new Array(); // 创建一个空数组
</code></pre></td></tr></table>
</div>
</div><h4 id="创建一个指定长度的数组">创建一个指定长度的数组</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var arr = new Array(size) // size 表示数组的长度
</code></pre></td></tr></table>
</div>
</div><h4 id="创建一个指定元素的数组">创建一个指定元素的数组</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var arr = new Array(1,2,3,4,5) //创建数组并赋值 [1,2,3,4,5]
</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<h3 id="二检测方法">二、检测方法</h3>
<h4 id="1利用-instanceof-操作符">1、利用 instanceof 操作符</h4>
<p>instanceof操作符是检测对象的原型链是否指向构造函数的prototype对象,</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var arr =[1,2,3];
console.log(arr instanceof Array) // true
</code></pre></td></tr></table>
</div>
</div><h4 id="2通过对象自身的-constructor-属性">2、通过对象自身的 constructor 属性</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var arr =[1,2,3];
console.log(arr.constructor === Array) // true
</code></pre></td></tr></table>
</div>
</div><p><strong>跨frame实例化对象带来的问题</strong></p>
<p><code>constructor</code> 和 <code>instanceof</code> 貌似很好的两个检测数组的方法，但实际上还是有些漏洞的，当你在多个frame中回来跳的时候，这两种方法就惨了。</p>
<p>由于每一个frame都有自己的一套执行环境，跨frame实例化的对象彼此并不共享原型链，通过 <code>instanceof</code> 操作符和 <code>constructor</code> 属性检测的方法自然会失败。</p>
<p>那么第三种方法就比较好了，如下</p>
<h4 id="3对象原生tostring检测">3、对象原生toString检测</h4>
<p><code>Object.prototype.toString</code> 的行为：首先，取得对象的一个内部属性 [[Class]]，然后依据这个属性，返回一个类似于&rdquo;[object Array]&ldquo;的字符串作为结果(看过ECMA标准的应该都知道，[[]]用来表示语言内部用到的、外部不可直接访问的属性，称为“内部属性”)。利用这 个方法，再配合call，我们可以取得任何对象的内部属性[[Class]]，然后把类型检测转化为字符串比较，以达到我们的目的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var arr =[1,2,3];
console.log(Object.prototype.toString.call(arr) === &#39;[object Array]&#39;); //true

</code></pre></td></tr></table>
</div>
</div><p>可以将判断方法封装一个函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">function isArray(obj) {
   return Object.prototype.toString.call(obj) === &#39;[object Array]&#39;;
}
var arr =[1,2,3];
console.log(isArray(arr)); // true

</code></pre></td></tr></table>
</div>
</div><h4 id="4ecmascript-5的isarray函数">4、ECMAScript 5的isArray函数</h4>
<p>为了让数组检测更方便，ECMAScript5新增了Array.isArray()方法。该方法的目的是最终确定某个值到底是不是数组，而不管它在哪个全局环境中创建的。</p>
<p><strong>注：此方法在IE8之前的版本是不支持的</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var arr =[1,2,3];
console.log(Array.isArray(arr)); // true

</code></pre></td></tr></table>
</div>
</div><h2 id="ecm3方法">ECM3方法</h2>
<h3 id="1arrayprototypejoin">1、Array.prototype.join()</h3>
<p><code>join()</code> 方法将数组（或一个类数组对象）的所有元素连接到一个字符串中。此方法不会改变原数组。也就是说所有的数组元素被转换成字符串，再用一个分隔符将这些字符串连接起来。如果元素是undefined 或者null， 则会转化成空字符串。</p>
<p><code>arr.join(separator)</code> 参数 <code>separator</code></p>
<ul>
<li>指定一个字符串来分隔数组的每个元素</li>
<li>如果省略()，数组元素用逗号分隔。默认为 &ldquo;,&rdquo;</li>
<li>如果separator是空字符串(&quot;&quot;)，则所有元素之间都没有任何字符</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var arr = [&#39;a1&#39;, &#39;b2&#39;, &#39;c3&#39;];
var myArr1 = arr.join();
var myArr2 = arr.join(&#39;, &#39;);
var myArr3 = arr.join(&#39; + &#39;);
var myArr4 = arr.join(&#39;&#39;);

console.log(myArr1);  // a1,b2,c3
console.log(myArr2);  // a1, b2, c3
console.log(myArr3);  // a1 + b2 + c3
console.log(myArr4);  // a1b2c3
</code></pre></td></tr></table>
</div>
</div><h3 id="2arrayprototypepush">2、Array.prototype.push()</h3>
<p>push() 方法将一个或多个元素添加到数组的末尾，并返回数组的新长度。</p>
<p>**添加元素：**可以添加新的元素到数组</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">// 添加元素
var letter = [&#34;a&#34;, &#34;b&#34;];
var total = letter.push(&#34;c&#34;,&#34;d&#34;);
console.log(total); // 4
console.log(letter); // [&#34;a&#34;, &#34;b&#34;, &#34;c&#34;, &#34;d&#34;]
</code></pre></td></tr></table>
</div>
</div><p><strong>合并数组</strong>：可以使用 apply() 添加第二个数组的所有元素</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">// 合并数组
var arr1 = [1, 2];
var arr2 = [&#34;a&#34;, &#34;b&#34;];

// 将第二个数组融合进第一个数组
// 相当于 arr1.push(&#39;a&#39;, &#39;b&#39;);
Array.prototype.push.apply(arr1, arr2);

console.log(arr1); // [1, 2, &#34;a&#34;, &#34;b&#34;]

</code></pre></td></tr></table>
</div>
</div><h3 id="3arrayprototypepop">3、Array.prototype.pop()</h3>
<p>pop()方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。</p>
<p>如果你在一个空数组上调用 pop()，它返回  undefined。</p>
<h3 id="4arrayprototypeunshift">4、Array.prototype.unshift()</h3>
<p>unshift() 方法将一个或多个元素添加到数组的开头，并返回新数组的长度。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var arr = [1, 2];

arr.unshift(0);
//arr is [0, 1, 2]

arr.unshift(-2, -1); // = 5
//arr is [-2, -1, 0, 1, 2]

arr.unshift( [-3] );
//arr is [[-3], -2, -1, 0, 1, 2]
</code></pre></td></tr></table>
</div>
</div><h3 id="5arrayprototypeshift">5、Array.prototype.shift()</h3>
<p>shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">let myFish = [&#39;angel&#39;, &#39;clown&#39;, &#39;mandarin&#39;, &#39;surgeon&#39;];

console.log(&#39;调用 shift 之前: &#39; + myFish);
// &#34;调用 shift 之前: angel,clown,mandarin,surgeon&#34;

var shifted = myFish.shift();

console.log(&#39;调用 shift 之后: &#39; + myFish);
// &#34;调用 shift 之后: clown,mandarin,surgeon&#34;

console.log(&#39;被删除的元素: &#39; + shifted);
// &#34;被删除的元素: angel&#34;
</code></pre></td></tr></table>
</div>
</div><h3 id="6arrayprototypesort">6、Array.prototype.sort()</h3>
<p>sort(compareFunction) 方法在适当的位置对数组的元素进行排序，并返回数组。</p>
<p>sort 排序不一定是稳定的。默认排序顺序是根据字符串Unicode码点。</p>
<p>一般我们给sort带入个比较函数来替代原来的默认的比较方法，比较方法接受两个参数:</p>
<ul>
<li>如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；</li>
<li>如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。</li>
<li>如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。</li>
<li>compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var numbers = [4, 2, 5, 1, 3];
numbers.sort(function(a, b) {
  return a - b;
});
console.log(numbers); // [1, 2, 3, 4, 5]
</code></pre></td></tr></table>
</div>
</div><h3 id="7arrayprototypereverse">7、Array.prototype.reverse()</h3>
<p>reverse() 方法颠倒数组中元素的位置。第一个元素会成为最后一个，最后一个会成为第一个。</p>
<p>下例将会创建一个数组 myArray，其包含三个元素，然后颠倒该数组。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var myArray = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
myArray.reverse();
console.log(myArray);  // [&#39;c&#39;, &#39;b&#39;, &#39;a&#39;]
</code></pre></td></tr></table>
</div>
</div><h3 id="8arrayprototypeconcat">8、Array.prototype.concat()</h3>
<p>concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var arr1 = [&#34;a&#34;, &#34;b&#34;, &#34;c&#34;];
var arr2 = [&#34;d&#34;, &#34;e&#34;, &#34;f&#34;];

var arr3 = arr1.concat(arr2);

console.log(arr3);
// 返回结果是一个新数组
// [ &#34;a&#34;, &#34;b&#34;, &#34;c&#34;, &#34;d&#34;, &#34;e&#34;, &#34;f&#34; ]

// 原数组没有改变
console.log(arr1); // [&#34;a&#34;, &#34;b&#34;, &#34;c&#34;]
console.log(arr2); // [&#34;d&#34;, &#34;e&#34;, &#34;f&#34;]
</code></pre></td></tr></table>
</div>
</div><h3 id="9arrayprototypeslice">9、Array.prototype.slice()</h3>
<p><code>slice(start, end)</code> 方法将数组的一部分浅拷贝, 返回到从开始到结束（不包括结束）选择的新数组对象。原始数组不会被修改。</p>
<ul>
<li>slice()</li>
<li>slice(start)</li>
<li>slice(start,end)</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var arr = [&#39;one&#39;,&#39;two&#39;,&#39;three&#39;,&#39;four&#39;];

//如果不传参数，表示从数组0开始到到end（包含end）
var newArr1 = arr.slice();
console.log(newArr1)  // [&#34;one&#34;, &#34;two&#34;, &#34;three&#34;, &#34;four&#34;]

//如果省略 end，则表示从start开始到end（包含end）
var newArr2 = arr.slice(1);
console.log(newArr2) // [&#34;two&#34;, &#34;three&#34;, &#34;four&#34;]

//如果传人star、end，则表示从start到end不包含end
var newArr3 = arr.slice(1, 3);
console.log(newArr3) // [&#34;two&#34;, &#34;three&#34;]

console.log(arr)    // [&#34;one&#34;, &#34;two&#34;, &#34;three&#34;, &#34;four&#34;]

</code></pre></td></tr></table>
</div>
</div><h3 id="10arrayprototypesplice">10、Array.prototype.splice()</h3>
<p>splice() 方法通过删除现有元素和/或添加新元素来更改数组的内容。</p>
<p><strong>注意：splice 方法直接更改原数组内容</strong></p>
<ul>
<li>array.splice(start)</li>
<li>array.splice(start, deleteCount)</li>
<li>array.splice(start, deleteCount, item1, item2, &hellip;)</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var myFish = [&#34;angel&#34;, &#34;clown&#34;, &#34;mandarin&#34;, &#34;surgeon&#34;];

//从第 2 位开始删除 0 个元素，插入 &#34;drum&#34;
var removed = myFish.splice(2, 0, &#34;drum&#34;);
console.log(myFish);
//运算后的 myFish:[&#34;angel&#34;, &#34;clown&#34;, &#34;drum&#34;, &#34;mandarin&#34;, &#34;surgeon&#34;]
//被删除元素数组：[]，没有元素被删除

//从第 3 位开始删除 1 个元素
removed = myFish.splice(3, 1);
//运算后的myFish：[&#34;angel&#34;, &#34;clown&#34;, &#34;drum&#34;, &#34;surgeon&#34;]
//被删除元素数组：[&#34;mandarin&#34;]

//从第 2 位开始删除 1 个元素，然后插入 &#34;trumpet&#34;
removed = myFish.splice(2, 1, &#34;trumpet&#34;);
//运算后的myFish: [&#34;angel&#34;, &#34;clown&#34;, &#34;trumpet&#34;, &#34;surgeon&#34;]
//被删除元素数组：[&#34;drum&#34;]

//从第 0 位开始删除 2 个元素，然后插入 &#34;parrot&#34;, &#34;anemone&#34; 和 &#34;blue&#34;
removed = myFish.splice(0, 2, &#34;parrot&#34;, &#34;anemone&#34;, &#34;blue&#34;);
//运算后的myFish：[&#34;parrot&#34;, &#34;anemone&#34;, &#34;blue&#34;, &#34;trumpet&#34;, &#34;surgeon&#34;]
//被删除元素的数组：[&#34;angel&#34;, &#34;clown&#34;]

//从第 3 位开始删除 2 个元素
removed = myFish.splice(3, Number.MAX_VALUE);
//运算后的myFish: [&#34;parrot&#34;, &#34;anemone&#34;, &#34;blue&#34;]
//被删除元素的数组：[&#34;trumpet&#34;, &#34;surgeon&#34;]
</code></pre></td></tr></table>
</div>
</div><hr>
<h2 id="ecm5方法">ECM5方法</h2>
<h3 id="1arrayprototypeindexof">1、Array.prototype.indexOf()</h3>
<p>indexOf()方法返回在数组中可以找到给定元素的第一个索引，如果不存在，则返回-1。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var a = [2, 6, 9, 6];

a.indexOf(2); // 0
a.indexOf(7); // -1 不存在
a.indexOf(6); // 1 返回指定元素的第一个索引值

</code></pre></td></tr></table>
</div>
</div><p><strong>找出指定元素出现的所有位置</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">// 找出 a 在 array 里的所有位置
var str = &#39;a&#39;;
var array = [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;a&#39;, &#39;d&#39;];


var indices = [];
var idx = array.indexOf(str);

while (idx != -1) {
  indices.push(idx);
  idx = array.indexOf(str, idx + 1);
}

console.log(indices);
// [0, 2, 4]
</code></pre></td></tr></table>
</div>
</div><h3 id="2arrayprototypelastindexof">2、Array.prototype.lastIndexOf()</h3>
<p>lastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">arr.lastIndexOf(searchElement[, fromIndex = arr.length - 1])
</code></pre></td></tr></table>
</div>
</div><p><strong>定位数组中的值：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var array = [2, 5, 9, 2];
var index = array.lastIndexOf(2);
// index is 3
index = array.lastIndexOf(7);
// index is -1
index = array.lastIndexOf(2, 3);
// index is 3
index = array.lastIndexOf(2, 2);
// index is 0
index = array.lastIndexOf(2, -2);
// index is 0
index = array.lastIndexOf(2, -1);
// index is 3
</code></pre></td></tr></table>
</div>
</div><p><strong>查找所有元素</strong></p>
<p>下例使用 lastIndexOf 查找到一个元素在数组中所有的索引（下标），并使用 push 将所有添加到另一个数组中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">
var element = &#39;a&#39;;
var array = [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;a&#39;, &#39;d&#39;];

var indices = [];
var idx = array.lastIndexOf(element);

while (idx != -1) {
  indices.push(idx);
  idx = (idx &gt; 0 ? array.lastIndexOf(element, idx - 1) : -1);
}

console.log(indices);
// [4, 2, 0];
</code></pre></td></tr></table>
</div>
</div><h3 id="3arrayprototypeevery">3、Array.prototype.every()</h3>
<p>every() 方法测试数组的所有元素是否都通过了指定函数的测试。</p>
<p>every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个使 callback 返回 false（表示可转换为布尔值 false 的值）的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。callback 只会为那些已经被赋值的索引调用。不会为那些被删除或从来没被赋值的索引调用。</p>
<p>callback 被调用时传入三个参数：元素值，元素的索引，原数组。</p>
<p>如果为 every 提供一个 thisArg 参数，在该参数为调用 callback 时的 this 值。如果省略该参数，则 callback 被调用时的 this 值，在非严格模式下为全局对象，在严格模式下传入 undefined。</p>
<p>every 不会改变原数组。</p>
<p>every 遍历的元素范围在第一次调用 callback 之前就已确定了。在调用 every 之后添加到数组中的元素不会被 callback 访问到。如果数组中存在的元素被更改，则他们传入 callback 的值是 every 访问到他们那一刻的值。那些被删除的元素或从来未被赋值的元素将不会被访问到。</p>
<p><strong>检测所有数组元素的大小</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">function isBigEnough(element, index, array) {
  return (element &gt;= 10);
}
var passed = [12, 5, 8, 130, 44].every(isBigEnough);
// passed is false
passed = [12, 54, 18, 130, 44].every(isBigEnough);
// passed is true
</code></pre></td></tr></table>
</div>
</div><h3 id="4arrayprototypesome">4、Array.prototype.some()</h3>
<p>some() 方法测试数组中的某些元素是否通过了指定函数的测试。</p>
<p>some 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个“真值”（即可转换为布尔值 true 的值）。如果找到了这样一个值，some 将会立即返回 true。否则，some 返回 false。callback 只会在那些”有值“的索引上被调用，不会在那些被删除或从来未被赋值的索引上调用。</p>
<p>callback 被调用时传入三个参数：元素的值，元素的索引，被遍历的数组。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">arr.some(callback[, thisArg])
</code></pre></td></tr></table>
</div>
</div><p>如果为 some 提供了一个 thisArg 参数，将会把它传给被调用的 callback，作为 this 值。否则，在非严格模式下将会是全局对象，严格模式下是 undefined。</p>
<p>some 被调用时不会改变数组。</p>
<p><strong>测试数组元素的值</strong></p>
<p>下面的例子检测在数组中是否有元素大于 10。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">function isBigEnough(element, index, array) {
  return (element &gt;= 10);
}
var passed = [2, 5, 8, 1, 4].some(isBigEnough);
// passed is false
passed = [12, 5, 8, 1, 4].some(isBigEnough);
// passed is true
</code></pre></td></tr></table>
</div>
</div><h3 id="5arrayprototypefilter">5、Array.prototype.filter()</h3>
<p>filter() 方法使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组。</p>
<p>对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var new_array = arr.filter(callback[, thisArg])
</code></pre></td></tr></table>
</div>
</div><p><strong>筛选排除掉所有的小值</strong></p>
<p>下例使用 filter 创建了一个新数组，该数组的元素由原数组中值大于 10 的元素组成。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">function isBigEnough(value) {
  return value &gt;= 10;
}

var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);
// filtered is [12, 130, 44]
</code></pre></td></tr></table>
</div>
</div><h3 id="6arrayprototypemap">6、Array.prototype.map()</h3>
<p>map() 方法创建一个新数组，其结果是该数组中的每个元素调用一个提供的函数，<strong>返回这个新数组</strong>。</p>
<p><strong>求数组中每个元素的平方根</strong></p>
<p>下面的代码创建了一个新数组，值为原数组中对应数字的平方根。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var numbers = [1, 4, 9];
var roots = numbers.map(Math.sqrt);
/* roots的值为[1, 2, 3], numbers的值仍为[1, 4, 9] */
</code></pre></td></tr></table>
</div>
</div><p><strong>问答题</strong></p>
<p>问题：<code>[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;].map(parseInt)</code> 答案是多少？</p>
<p>答案是<code>[1,NaN,NaN]</code></p>
<h3 id="7arrayprototypeforeach">7、Array.prototype.forEach()</h3>
<p>forEach() 方法对数组的每个元素执行一次提供的函数。</p>
<p>对数组中的每一项运行给定函数，这个方法没有返回值。本质上与使用 for 循环迭代数组一样。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">array.forEach(callback(currentValue, index, array){
    //do something
}, this)
</code></pre></td></tr></table>
</div>
</div><ul>
<li>currentValue(当前值) 数组中正在处理的当前元素。</li>
<li>index(索引) 数组中正在处理的当前元素的索引。</li>
<li>array forEach()方法正在操作的数组。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var arr=[2, 4, 5];
arr.forEach(function(elm,index, array) {
   console.log(index, elm);
});

// 0 2
// 1 4
// 2 5

</code></pre></td></tr></table>
</div>
</div><h3 id="8arrayprototypereduce">8、Array.prototype.reduce()</h3>
<p>reduce() 方法对累加器和数组的每个值 (从左到右)应用一个函数，以将其减少为单个值。</p>
<p><strong>将数组所有项相加</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var sum = [0, 1, 2, 3].reduce(function(a, b) {
    return a + b;
}, 0);
// sum is 6
</code></pre></td></tr></table>
</div>
</div><p><strong>数组扁平化</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var flattened = [[0, 1], [2, 3], [4, 5]].reduce(function(a, b) {
    return a.concat(b);
}, []);
// flattened is [0, 1, 2, 3, 4, 5]
</code></pre></td></tr></table>
</div>
</div><h3 id="9arrayprototypereduceright">9、Array.prototype.reduceRight()</h3>
<p>reduceRight() 方法接受一个函数作为累加器（accumulator），让每个值（从右到左，亦即从尾到头）缩减为一个值。（与 reduce() 的执行方向相反）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var flattened = [[0, 1], [2, 3], [4, 5]].reduceRight(function(a, b) {
    return a.concat(b);
}, []);

// flattened is [4, 5, 2, 3, 0, 1]
</code></pre></td></tr></table>
</div>
</div><hr>
<blockquote>
<p>本文主要内容引用：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array">MDN 的 JavaScript 标准库 Array 部分</a></li>
<li><a href="http://www.w3cplus.com/">W3cplus 博客</a></li>
</ul>
</blockquote>
<p>原文地址: <a href="http://zyj1022.github.io/posts/frontend/2017/js-array-base.html">http://zyj1022.github.io/posts/frontend/2017/js-array-base.html</a></p>
<p>转载时必须以链接形式注明原始出处及本声明</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">ZHIKING</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2017-03-22
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/js/">js</a>
          <a href="/tags/frontend/">frontend</a>
          <a href="/tags/array/">array</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2017/js-class3/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Javascript定义类（class）的三种方法</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/2017/js-oop/">
            <span class="next-text nav-default">Javascript 面向对象编程详解</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  
  <div id="vcomments"></div>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script type="text/javascript">
    new Valine({
        el: '#vcomments' ,
        appId: 'NMSmBidAFpBuTSH8keGTVxsp-gzGzoHsz',
        appKey: 'hyRs458vliUABVCeqmXstLsE',
        notify:  false ,
        verify:  false ,
        avatar:'mm',
        placeholder: '看完了，你有啥想吐槽的...',
        visitor:  false 
    });
  </script>

  
    <script src="https://utteranc.es/client.js"
            repo="zyj1022/"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:zyj10222@126.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/zyj1022" class="iconfont icon-github" title="github"></a>
      <a href="https://weibo.com/zyj1022" class="iconfont icon-weibo" title="weibo"></a>
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2015 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">ZHIKING</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.cddea96674a99fd8cea50d36fb19d9c91f497feea4af5ce4596afd2dbaab9202.js"></script>








</body>
</html>
