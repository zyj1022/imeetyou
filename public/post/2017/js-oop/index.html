<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Javascript 面向对象编程详解 - 知也无涯</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="ZHIKING" /><meta name="description" content="Javascript是一种基于对象的语言，秉承一切皆对象的理念。 但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有cla" /><meta name="keywords" content="Hugo, blog, 智的博客" />






<meta name="generator" content="Hugo 0.69.0 with theme even" />


<link rel="canonical" href="/post/2017/js-oop/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Javascript 面向对象编程详解" />
<meta property="og:description" content="Javascript是一种基于对象的语言，秉承一切皆对象的理念。 但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有cla" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/2017/js-oop/" />
<meta property="article:published_time" content="2017-03-18T18:24:26+08:00" />
<meta property="article:modified_time" content="2017-03-18T18:24:26+08:00" />
<meta itemprop="name" content="Javascript 面向对象编程详解">
<meta itemprop="description" content="Javascript是一种基于对象的语言，秉承一切皆对象的理念。 但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有cla">
<meta itemprop="datePublished" content="2017-03-18T18:24:26&#43;08:00" />
<meta itemprop="dateModified" content="2017-03-18T18:24:26&#43;08:00" />
<meta itemprop="wordCount" content="4827">



<meta itemprop="keywords" content="oop,js,frontend," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Javascript 面向对象编程详解"/>
<meta name="twitter:description" content="Javascript是一种基于对象的语言，秉承一切皆对象的理念。 但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有cla"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->


<script data-ad-client="ca-pub-3216129127646136" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>



<script src="/js/baidutongji.js" async="true"></script>

<script src="/js/baidutuisong.js" async="true"></script>

<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery-modal/0.9.1/jquery.modal.min.css" />

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">知也无涯</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">知也无涯</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
	
    <a href="#ex1" rel="modal:open"><i class="fas fa-search fa-fw"></i></a>
    
  </ul>

</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Javascript 面向对象编程详解</h1>

      <div class="post-meta">
        <span class="post-time"> 2017-03-18 </span>
        <div class="post-category">
            <a href="/categories/frontend/"> frontend </a>
            </div>
          <span class="more-meta"> 约 4827 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#第一种借用构造函数经典继承">第一种，借用构造函数（经典继承）</a></li>
    <li><a href="#第二种原型prototype继承">第二种，原型prototype继承</a>
      <ul>
        <li><a href="#1使用prototype属性继承">1、使用prototype属性继承</a></li>
        <li><a href="#2直接继承prototype">2、直接继承prototype</a></li>
      </ul>
    </li>
    <li><a href="#第三种-组合继承">第三种 组合继承</a></li>
    <li><a href="#第四种利用空对象作为中介寄生组合式继承">第四种，利用空对象作为中介(寄生组合式继承)</a></li>
    <li><a href="#第五种-拷贝继承">第五种， 拷贝继承</a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#第一种-object方法">第一种 object()方法</a></li>
        <li><a href="#第二种-浅拷贝">第二种 浅拷贝</a></li>
        <li><a href="#第三种-深拷贝">第三种 深拷贝</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Javascript是一种基于对象的语言，秉承一切皆对象的理念。</p>
<p>但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有class（类）。我们知道面向对象编程的三大特征就是封装、继承、多态</p>
<p>那么如何用 Javascript 来实现面向对象编程呢</p>
<h1 id="1利用prototype模式实现封装">1、利用Prototype模式实现封装</h1>
<p>在Javascript里每一个构造函数都有一个<code>prototype</code>属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</p>
<p>这样，我们把那些不变的属性和方法，直接定义在<code>prototype</code>对象上</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">function Person(name,age) {
    this.name = name;
    this.age = age;
}

Person.prototype.legs = 2
Person.prototype.speak = function() {
	console.log(&#34;我的名字是：&#34; + this.name + &#34;，年龄：&#34; + this.age);
}

</code></pre></td></tr></table>
</div>
</div><p>然后，生成实例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var jack = new Person(&#34;jack&#34;, 26);
var lily = new Person(&#34;lily&#34;, 25);

jack.legs; // 2
lily.speak() // 我的名字是：lily，年龄：25

</code></pre></td></tr></table>
</div>
</div><!-- raw HTML omitted -->
<h1 id="2实现构造函数继承的五种方法">2、实现构造函数继承的五种方法</h1>
<p>举例，有一个水果的构造函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">function Fruit() {
  this.type = &#34;水果&#34;;
}
</code></pre></td></tr></table>
</div>
</div><p>还有个“苹果”的构造函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">function Apple(name, color) {
	this.name = name;
	this.color = color;
}
</code></pre></td></tr></table>
</div>
</div><p>怎么使得 <code>Apple</code> 继承 <code>Fruit</code> 呢？</p>
<h2 id="第一种借用构造函数经典继承">第一种，借用构造函数（经典继承）</h2>
<p><strong>使用call/apply，构造函数绑定</strong>，如题，使用<code>call</code>或<code>apply</code>方法，将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行</p>
<blockquote>
<p>基本思想:即在子类型构造函数的内部调用超类型构造函数.</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">function Fruit() {
  this.type = &#34;水果&#34;;
}

function Apple(name,color) {
    // 继承了Fruit，且向父类传递参数
	Fruit.apply(this, arguments); // 这里用call也可以
	this.name = name;
	this.color = color;
}

var a = new Apple(&#34;苹果&#34;, &#34;红色&#34;);
console.log(a.type) // 水果
a.type = &#34;南瓜&#34; // 这里修改父类的属性值
console.log(a.type) // 南瓜

var b = new Apple();
console.log(b.type); // 水果 可见引用类型值是独立的

</code></pre></td></tr></table>
</div>
</div><p>在这里，借用构造函数解决了原型链的两个问题：</p>
<ul>
<li>保证了原型链中引用类型值的独立,不再被所有实例共享;</li>
<li>子类型创建时也能够向父类型传递参数.</li>
</ul>
<p>随之而来的是, 如果仅仅借用构造函数,那么将无法避免构造函数模式存在的问题&ndash;方法都在构造函数中定义, 因此函数复用也就不可用了.而且超类型(如Fruit)中定义的方法,对子类型而言也是不可见的. 考虑此,借用构造函数的技术也很少单独使用.</p>
<h2 id="第二种原型prototype继承">第二种，原型prototype继承</h2>
<h3 id="1使用prototype属性继承">1、使用prototype属性继承</h3>
<p>第二种方法比较常见，使用prototype属性。</p>
<p>如果水果的prototype对象，指向一个Fruit的实例，那么所有&quot;水果&quot;的实例，就能继承Fruit了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">function Fruit() {
  this.type = &#34;水果&#34;;
}

function Apple(name, color) {
	this.name = name;
	this.color = color;
}

/*
* 将 Apple 的 prototype 对象指向 Fruit实例，
* 它相当于完全删除了prototype 对象原先的值，然后赋予一个新值
*／
Apple.prototype = new Fruit();

// 将 Apple 的 prototype 对象的构造函数指回原来的构造函数
Apple.prototype.constructor = Apple;

var a2 = new Apple(&#34;香蕉苹果&#34;, &#34;黄色&#34;);
console.log(a2.type) // 水果

</code></pre></td></tr></table>
</div>
</div><h3 id="2直接继承prototype">2、直接继承prototype</h3>
<p>这里第2种方法是对第1种方法的改进。由于Fruit对象中，不变的属性都可以直接写入Fruit.prototype。
所以，我们也可以让Apple()跳过 Fruit()，直接继承Fruit.prototype。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">function Fruit() {}
Fruit.prototype.type = &#34;水果&#34;;

function Apple(name, color) {
	this.name = name;
    this.color = color;
}

Apple.prototype = Fruit.prototype;
Apple.prototype.constructor = Apple; // 实际上把Fruit.prototype对象的constructor属性也改掉了
var a2 = new Apple(&#34;香蕉苹果&#34;, &#34;黄色&#34;);
console.log(a2.type) // 水果

</code></pre></td></tr></table>
</div>
</div><p>与前一种方法相比，这样做的优点是效率比较高（不用执行和建立Fruit的实例了），比较省内存。缺点是 <code>Apple.prototype</code>和<code>Fruit.prototype</code>现在指向了同一个对象，那么任何对<code>Apple.prototype</code>的修改，都会反映到<code>Fruit.prototype</code>。</p>
<p>所以，上面这一段代码其实是有问题的。请看这行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">Apple.prototype.constructor = Apple;
</code></pre></td></tr></table>
</div>
</div><p>这一句实际上把 <code>Fruit.prototype</code> 对象的 <code>constructor</code> 属性也改掉了！</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">alert(Fruit.prototype.constructor); // Apple
</code></pre></td></tr></table>
</div>
</div><h2 id="第三种-组合继承">第三种 组合继承</h2>
<p>组合继承, 有时候也叫做伪经典继承,指的是将原型链和借用构造函数的技术组合到一块,从而发挥两者之长的一种继承模式.</p>
<blockquote>
<p>基本思路: 使用原型链实现对原型属性和方法的继承,通过借用构造函数来实现对实例属性的继承.</p>
</blockquote>
<p>这样,既通过在原型上定义方法实现了函数复用,又能保证每个实例都有它自己的属性. 如下.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">function Fruit() {
  this.type = &#39;水果&#39;;
}
Fruit.prototype.getType = function() {
    console.log(this.type);
}

function Apple(name,color) {
	Fruit.apply(this, arguments); // 继承实例属性，第一次调用Fruit，
    this.name = name;
	this.color = color;
}

Apple.prototype = new Fruit(name); // 继承父类方法，第二次调用Fruit
Apple.prototype.getColor = function() {
    console.log(this.color)
}

var ap1 = new Apple(&#34;苹果&#34;, &#34;红色&#34;);
ap1.type = &#39;红富士&#39;
ap1.getType(); // &#39;红富士&#39;
ap1.getColor(); // &#39;红色&#39;

var ap2 = new Apple(&#39;香蕉苹果&#39;,&#34;黄色&#34;)
console.log(ap2.type); // 水果
ap2.getType(); // &#39;水果&#39;
ap2.getColor(); // &#39;红色&#39;

</code></pre></td></tr></table>
</div>
</div><p>组合继承避免了原型链和借用构造函数的缺陷,融合了它们的优点,成为 JavaScript 中<strong>最常用的继承模式</strong>. 而且, <code>instanceof</code> 和 <code>isPrototypeOf()</code> 也能用于识别基于组合继承创建的对象.</p>
<p>同时我们还注意到组合继承其实调用了两次父类构造函数, 造成了不必要的消耗, 那么怎样才能避免这种不必要的消耗呢?</p>
<h2 id="第四种利用空对象作为中介寄生组合式继承">第四种，利用空对象作为中介(寄生组合式继承)</h2>
<p>由于前面的 &ldquo;直接继承prototype&rdquo; 存在上述的缺点，所以就有第四种方法，利用一个空对象作为中介</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">function Fruit() {}
Fruit.prototype.type = &#34;水果&#34;;

function Apple(name, color) {
	this.name = name;
    this.color = color;
}

var F = function(){}; // F是空对象，所以几乎不占内存
F.prototype = Fruit.prototype;
Apple.prototype = new F(); // 修改Apple的prototype对象，就不会影响到Fruit的prototype对象
Apple.prototype.constructor = Apple;

var a2 = new Apple(&#34;香蕉苹果&#34;, &#34;黄色&#34;);
console.log(a2.type) // 水果

</code></pre></td></tr></table>
</div>
</div><p>将上面方法，封装一个函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">function extend(Child, Parent) {
　　var F = function(){};
　　F.prototype = Parent.prototype;
　　Child.prototype = new F();
　　Child.prototype.constructor = Child;
　　Child.uber = Parent.prototype;
}
</code></pre></td></tr></table>
</div>
</div><p>使用的时候，方法如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">extend(Apple,Fruit)
var a2 = new Apple(&#34;香蕉苹果&#34;, &#34;黄色&#34;);
console.log(a2.type) // 水果
</code></pre></td></tr></table>
</div>
</div><p>这个extend函数，就是YUI库如何实现继承的方法。
另外，说明一点，函数体最后一行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">Child.uber = Parent.prototype;
</code></pre></td></tr></table>
</div>
</div><p>意思是为子对象设一个uber属性，这个属性直接指向父对象的prototype属性。（uber是一个德语词，意思是&quot;向上&rdquo;、&ldquo;上一层&rdquo;。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。</p>
<h2 id="第五种-拷贝继承">第五种， 拷贝继承</h2>
<p>上面是采用prototype对象，实现继承。我们也可以换一种思路，纯粹采用&quot;拷贝&quot;方法实现继承。简单说，如果把父对象的所有属性和方法，拷贝进子对象，不也能够实现继承吗？这样我们就有了第五种方法。</p>
<p>首先，还是把Fruit的所有不变属性，都放到它的prototype对象上。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">function Fruit(){}
Fruit.prototype.type = &#34;水果&#34;;
</code></pre></td></tr></table>
</div>
</div><p>然后，写一个函数，实现属性拷贝的目的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">function extend2(Child, Parent) {
　　var p = Parent.prototype;
　　var c = Child.prototype;
　  for (var i in p) {
　　　　	c[i] = p[i];
　　}
　　c.uber = p;
}
</code></pre></td></tr></table>
</div>
</div><p>这个函数的作用，就是将父对象的 prototype 对象中的属性，一一拷贝给 Child 对象的 prototype 对象。</p>
<p>使用的时候，这样写：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">extend2(Apple, Fruit);
var a2 = new Apple(&#34;香蕉苹果&#34;, &#34;黄色&#34;);
console.log(a2.type) // 水果
</code></pre></td></tr></table>
</div>
</div><h1 id="3不使用构造函数实现继承的方法">3、不使用构造函数实现&quot;继承&quot;的方法</h1>
<p><strong>什么是&quot;非构造函数&quot;的继承？</strong></p>
<p>比如，现在有一个对象，叫做&quot;中国人&rdquo;。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var Chinese = {
　　nation:&#39;中国&#39;
};
</code></pre></td></tr></table>
</div>
</div><p>还有一个对象，叫做&quot;医生&rdquo;。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var Doctor ={
　　career:&#39;医生&#39;
}
</code></pre></td></tr></table>
</div>
</div><p>请问怎样才能让&quot;医生&quot;去继承&quot;中国人&rdquo;，也就是说，我怎样才能生成一个&quot;中国医生&quot;的对象？</p>
<p>这里要注意，这两个对象都是普通对象，不是构造函数，无法使用构造函数方法实现&quot;继承&rdquo;。</p>
<h3 id="第一种-object方法">第一种 object()方法</h3>
<p>json格式的发明人Douglas Crockford，提出了一个object()函数，可以做到这一点。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">function object(o) {
　　function F() {}
　　F.prototype = o;
　　return new F();
}
</code></pre></td></tr></table>
</div>
</div><p>这个object()函数，其实只做一件事，就是把子对象的prototype属性，指向父对象，从而使得子对象与父对象连在一起。</p>
<p>使用的时候，第一步先在父对象的基础上，生成子对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var Doctor = object(Chinese);
</code></pre></td></tr></table>
</div>
</div><p>然后，再加上子对象本身的属性：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">Doctor.career = &#39;医生&#39;;
</code></pre></td></tr></table>
</div>
</div><p>这时，子对象已经继承了父对象的属性了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var Chinese = {
　　　nation:&#39;中国&#39;
};

var Doctor ={
　　　career:&#39;医生&#39;
}

function object(o) {
　　function F() {}
　　F.prototype = o;
　　return new F();
}

var Doctor = object(Chinese);

Doctor.career = &#39;医生&#39;;

alert(Doctor.nation); //中国

</code></pre></td></tr></table>
</div>
</div><p>在 ECMAScript5 中,通过新增 object.create() 方法规范化了上面的原型式继承.</p>
<p>object.create() 接收两个参数:</p>
<ul>
<li>一个用作新对象原型的对象</li>
<li>(可选的)一个为新对象定义额外属性的对象</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var Chinese = {
　　　nation:&#39;中国&#39;
};

var Doctor ={
　　　career:&#39;医生&#39;
}

var Doctor = Object.create(Chinese);

Doctor.career = &#39;医生&#39;;

alert(Doctor.nation); //中国
</code></pre></td></tr></table>
</div>
</div><p><code>object.create()</code> 只有一个参数时功能与上述<code>object</code>方法相同，目前支持 <code>Object.create()</code> 的浏览器有 IE9+, Firefox 4+, Safari 5+, Opera 12+ 和 Chrome.</p>
<h3 id="第二种-浅拷贝">第二种 浅拷贝</h3>
<p>除了使用&quot;prototype链&quot;以外，还有另一种思路：把父对象的属性，全部拷贝给子对象，也能实现继承。</p>
<p>下面这个函数，就是在做拷贝：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">function extendCopy(p) {
　　var c = {};
　　for (var i in p) {
　　　　c[i] = p[i];
　　}
　　c.uber = p;
　　return c;
}
</code></pre></td></tr></table>
</div>
</div><p>但是，这样的拷贝有一个问题。那就是，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能。</p>
<p>请看，现在给Chinese添加一个&quot;出生地&quot;属性，它的值是一个数组。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">Chinese.birthPlaces = [&#39;北京&#39;,&#39;上海&#39;,&#39;香港&#39;];
</code></pre></td></tr></table>
</div>
</div><p>通过extendCopy()函数，Doctor继承了Chinese。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var Doctor = extendCopy(Chinese);
</code></pre></td></tr></table>
</div>
</div><p>然后，我们为Doctor的&quot;出生地&quot;添加一个城市</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">Doctor.birthPlaces.push(&#39;厦门&#39;);
</code></pre></td></tr></table>
</div>
</div><p>发生了什么事？Chinese的&quot;出生地&quot;也被改掉了！</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门
alert(Chinese.birthPlaces); //北京, 上海, 香港, 厦门
</code></pre></td></tr></table>
</div>
</div><p>所以，extendCopy()只是拷贝基本类型的数据，我们把这种拷贝叫做&quot;浅拷贝&rdquo;。这是早期jQuery实现继承的方式。</p>
<h3 id="第三种-深拷贝">第三种 深拷贝</h3>
<p>所谓&quot;深拷贝&rdquo;，就是能够实现真正意义上的数组和对象的拷贝。它的实现并不难，只要递归调用&quot;浅拷贝&quot;就行了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">function deepCopy(p, c) {
　　　　var c = c || {};
　　　　for (var i in p) {
　　　　　　if (typeof p[i] === &#39;object&#39;) {
　　　　　　　　c[i] = (p[i].constructor === Array) ? [] : {};
　　　　　　　　deepCopy(p[i], c[i]);
　　　　　　} else {
　　　　　　　　　c[i] = p[i];
　　　　　　}
　　　　}
　　　　return c;
}
</code></pre></td></tr></table>
</div>
</div><p>使用的时候这样写：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var Doctor = deepCopy(Chinese);
</code></pre></td></tr></table>
</div>
</div><p>现在，给父对象加一个属性，值为数组。然后，在子对象上修改这个属性：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">Chinese.birthPlaces = [&#39;北京&#39;,&#39;上海&#39;,&#39;香港&#39;];
Doctor.birthPlaces.push(&#39;厦门&#39;);
</code></pre></td></tr></table>
</div>
</div><p>这时，父对象就不会受到影响了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门
alert(Chinese.birthPlaces); //北京, 上海, 香港
</code></pre></td></tr></table>
</div>
</div><p>目前，jQuery库使用的就是这种继承方法。</p>
<hr>
<blockquote>
<p>以上文章内容，转载修改自<a href="http://www.ruanyifeng.com/blog/javascript/">阮一峰的网络日志</a>，仅作学习总结，原文链接如下：</p>
<p><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html">Javascript面向对象编程（三）：非构造函数的继承</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html">Javascript面向对象编程（二）：构造函数的继承</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html">Javascript 面向对象编程（一）：封装</a></p>
</blockquote>
<p>本文地址: <a href="http://zyj1022.github.io/posts/frontend/2017/js-oop.html">http://zyj1022.github.io/posts/frontend/2017/js-oop.html</a></p>
<p>转载时必须以链接形式注明原始出处及本声明</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">ZHIKING</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2017-03-18
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/oop/">oop</a>
          <a href="/tags/js/">js</a>
          <a href="/tags/frontend/">frontend</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2017/js-array-base/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Javascript基础之数组</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/2017/2017-03-13/">
            <span class="next-text nav-default">归零重来</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  
  <div id="vcomments"></div>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script type="text/javascript">
    new Valine({
        el: '#vcomments' ,
        appId: 'NMSmBidAFpBuTSH8keGTVxsp-gzGzoHsz',
        appKey: 'hyRs458vliUABVCeqmXstLsE',
        notify:  false ,
        verify:  false ,
        avatar:'mm',
        placeholder: '看完了，你有啥想吐槽的...',
        visitor:  false 
    });
  </script>

  
    <script src="https://utteranc.es/client.js"
            repo="zyj1022/"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:zyj10222@126.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/zyj1022" class="iconfont icon-github" title="github"></a>
      <a href="https://weibo.com/zyj1022" class="iconfont icon-weibo" title="weibo"></a>
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">

  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>
  <a href="http://www.beian.miit.gov.cn">沪ICP备17033498号</a>


  

  <span class="copyright-year">
    &copy; 
    2015 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">ZHIKING</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>








<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.0.0/jquery.min.js"></script>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-modal/0.9.1/jquery.modal.min.js"></script>

<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/algoliasearch.min.js"></script>
<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/autocomplete.min.js"></script>

<script src="/js/search.js" async="true"></script>
  
  
  <div id="ex1" class="modal">
    <div class="aa-input-container" id="aa-input-container">
    <input type="search" id="aa-search-input" class="aa-input-search" placeholder="Search for titles or URIs..." name="search" autocomplete="off" />
    <svg class="aa-input-icon" viewBox="654 -372 1664 1664">
        <path d="M1806,332c0-123.3-43.8-228.8-131.5-316.5C1586.8-72.2,1481.3-116,1358-116s-228.8,43.8-316.5,131.5  C953.8,103.2,910,208.7,910,332s43.8,228.8,131.5,316.5C1129.2,736.2,1234.7,780,1358,780s228.8-43.8,316.5-131.5  C1762.2,560.8,1806,455.3,1806,332z M2318,1164c0,34.7-12.7,64.7-38,90s-55.3,38-90,38c-36,0-66-12.7-90-38l-343-342  c-119.3,82.7-252.3,124-399,124c-95.3,0-186.5-18.5-273.5-55.5s-162-87-225-150s-113-138-150-225S654,427.3,654,332  s18.5-186.5,55.5-273.5s87-162,150-225s138-113,225-150S1262.7-372,1358-372s186.5,18.5,273.5,55.5s162,87,225,150s113,138,150,225  S2062,236.7,2062,332c0,146.7-41.3,279.7-124,399l343,343C2305.7,1098.7,2318,1128.7,2318,1164z" />
    </svg>
</div>
  </div>

</body>
</html>
