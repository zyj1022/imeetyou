<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Strategy on 知也无涯</title>
    <link>/tags/strategy/</link>
    <description>Recent content in Strategy on 知也无涯</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>ZHIKING</copyright>
    <lastBuildDate>Sat, 01 Apr 2017 12:53:39 +0000</lastBuildDate>
    
	<atom:link href="/tags/strategy/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>设计模式之策略模式(Strategy)</title>
      <link>/post/2017/js-dp-strategy/</link>
      <pubDate>Sat, 01 Apr 2017 12:53:39 +0000</pubDate>
      
      <guid>/post/2017/js-dp-strategy/</guid>
      <description>&lt;p&gt;在程序设计中，我们也常常遇到这样的情况，要实现某一个功能有多种方案可以选择。比如一个压缩文件的程序，既可以选择 zip 算法，也可以选择 gzip 算法。
这些算法灵活多样，而且可以随意互相替换。这种解决方案就是将要介绍的策略模式。&lt;/p&gt;
&lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;
&lt;p&gt;策略模式的定义是:定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。&lt;/p&gt;
&lt;p&gt;从定义上看，策略模式就是用来封装算法的。但如果把策略模式仅仅用来封装算法，未免有一点大材小用。在实际开发中，我们通常会把算法的含义扩散开来，使策略模式也可以用来封装一系列的“业务规则”。只要这些业务规则指向的目标一致，并且可以被替换使用，我们就可以用策略模式来封装它们。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>