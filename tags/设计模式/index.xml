<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>设计模式 on 知也无涯</title><link>/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><description>Recent content in 设计模式 on 知也无涯</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>ZHIKING</copyright><lastBuildDate>Mon, 24 Apr 2017 17:26:19 +0000</lastBuildDate><atom:link href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>设计模式之适配器模式(Adapter)</title><link>/post/2017/js-dp-adapter/</link><pubDate>Mon, 24 Apr 2017 17:26:19 +0000</pubDate><guid>/post/2017/js-dp-adapter/</guid><description>&lt;h2 id="介绍">介绍&lt;/h2>
&lt;p>适配器模式（Adapter）是将一个类（对象）的接口（方法或属性）转化成客户希望的另外一个接口（方法或属性），适配器模式使得原本由于接口不兼容而不能一起工作的那些类（对象）可以一些工作。&lt;/p>
&lt;p>适配器的别名是包装器(wrapper)，这是一个相对简单的模式。&lt;/p>
&lt;h2 id="使用实例">使用实例&lt;/h2>
&lt;h3 id="现实中的适配器apple的各种转接头">现实中的适配器——apple的各种转接头&lt;/h3>
&lt;p>相信大家对apple对各种设备设计精良，用户使用方便比较赞同，但是针对各种转接头又有各种吐槽，其实转接头是不是就对应我们但适配器呢？&lt;/p></description></item><item><title>设计模式之装饰者模式(Decorator)</title><link>/post/2017/js-dp-decorator/</link><pubDate>Fri, 21 Apr 2017 09:16:39 +0000</pubDate><guid>/post/2017/js-dp-decorator/</guid><description>&lt;h2 id="介绍">介绍&lt;/h2>
&lt;p>装饰者提供比继承更有弹性的替代方案。 装饰者用用于包装同接口的对象，不仅允许你向方法添加行为，而且还可以将方法设置成原始对象调用（例如装饰者的构造函数）。&lt;/p>
&lt;p>装饰者用于通过重载方法的形式添加新功能，该模式可以在被装饰者前面或者后面加上自己的行为以达到特定的目的。&lt;/p>
&lt;h2 id="定义">定义&lt;/h2>
&lt;p>给对象动态地增加职责的方式称为装饰者(decorator)模式。&lt;/p>
&lt;p>装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责。跟继承相比，装饰者是一种更轻便灵活的做法，这是一种“即用即付”的方式。&lt;/p></description></item><item><title>设计模式之中介者模式(Mediator)</title><link>/post/2017/js-dp-mediator/</link><pubDate>Wed, 19 Apr 2017 12:36:29 +0000</pubDate><guid>/post/2017/js-dp-mediator/</guid><description>介绍 中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一</description></item><item><title>设计模式之职责链模式(Chain of responsibility)</title><link>/post/2017/js-dp-chain-of-responsibility/</link><pubDate>Mon, 17 Apr 2017 17:46:19 +0000</pubDate><guid>/post/2017/js-dp-chain-of-responsibility/</guid><description>定义 职责链模式的定义：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间 5 的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求</description></item><item><title>设计模式之享元模式(Flyweight)</title><link>/post/2017/js-dp-flyweight/</link><pubDate>Fri, 07 Apr 2017 12:36:39 +0000</pubDate><guid>/post/2017/js-dp-flyweight/</guid><description>介绍 享元(flyweight)模式是一种用于性能优化的模式，享元模式的核心是运用共享技术来有效支持大量细粒度的对象。 享元模式可以避免大量非常</description></item><item><title>设计模式之模板模式(TemplateMethod)</title><link>/post/2017/js-dp-template/</link><pubDate>Thu, 06 Apr 2017 17:54:16 +0800</pubDate><guid>/post/2017/js-dp-template/</guid><description>在 JavaScript 开发中用到继承的场景其实并不是很多，很多时候我们都喜欢用 mix-in 的方式给对象扩展属性。但这不代表继承在 JavaScript 里没有用武之地，虽然没有真正的类和继承</description></item><item><title>设计模式之发布/订阅模式(Publish/Subscribe)</title><link>/post/2017/js-dp-publish-subscribe/</link><pubDate>Wed, 05 Apr 2017 12:36:29 +0000</pubDate><guid>/post/2017/js-dp-publish-subscribe/</guid><description>发布/订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScript 开发中，我</description></item><item><title>设计模式之策略模式(Strategy)</title><link>/post/2017/js-dp-strategy/</link><pubDate>Sat, 01 Apr 2017 12:53:39 +0000</pubDate><guid>/post/2017/js-dp-strategy/</guid><description>&lt;p>在程序设计中，我们也常常遇到这样的情况，要实现某一个功能有多种方案可以选择。比如一个压缩文件的程序，既可以选择 zip 算法，也可以选择 gzip 算法。
这些算法灵活多样，而且可以随意互相替换。这种解决方案就是将要介绍的策略模式。&lt;/p>
&lt;h2 id="定义">定义&lt;/h2>
&lt;p>策略模式的定义是:定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。&lt;/p>
&lt;p>从定义上看，策略模式就是用来封装算法的。但如果把策略模式仅仅用来封装算法，未免有一点大材小用。在实际开发中，我们通常会把算法的含义扩散开来，使策略模式也可以用来封装一系列的“业务规则”。只要这些业务规则指向的目标一致，并且可以被替换使用，我们就可以用策略模式来封装它们。&lt;/p></description></item><item><title>设计模式之迭代器模式(Iterator)</title><link>/post/2017/js-dp-iterator/</link><pubDate>Fri, 31 Mar 2017 17:56:19 +0000</pubDate><guid>/post/2017/js-dp-iterator/</guid><description>&lt;p>迭代器模式是一种相对简单的模式，简单到很多时候我们都不认为它是一种设计模式。目前的绝大部分语言都内置了迭代器。&lt;/p>
&lt;p>比如：JavaScript 的 &lt;code>Array.prototype.forEach&lt;/code>&lt;/p>
&lt;p>jQuery里一个非常有名的迭代器就是 &lt;code>$.each&lt;/code> 方法，通过each我们可以传入额外的function，然后来对所有的item项进行迭代操作，例如：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">$.each( [1, 2, 3], function( i, n ){
console.log( &amp;#39;当前下标为： &amp;#39;+ i,&amp;#39;当前值为:&amp;#39; + n );
});
// 下标： 0 当前值:1
// 下标： 1 当前值:2
// 下标： 2 当前值:3
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>设计模式之代理模式（Proxy）</title><link>/post/2017/js-dp-proxy/</link><pubDate>Wed, 29 Mar 2017 18:16:09 +0000</pubDate><guid>/post/2017/js-dp-proxy/</guid><description>&lt;p>代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。&lt;/p>
&lt;p>代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身对象来控制对这个对象的访问，客户实际上访问的是替身对象。替身对象对请求做出一些处理之后，再把请求转交给本体对象。&lt;/p>
&lt;h2 id="定义">定义&lt;/h2>
&lt;p>代理，顾名思义就是帮助别人做事，GoF对代理模式的定义如下：&lt;/p>
&lt;blockquote>
&lt;p>代理模式（Proxy），为其他对象提供一种代理以控制对这个对象的访问。&lt;/p>
&lt;/blockquote></description></item><item><title>设计模式之单例模式(Singleton)</title><link>/post/2017/js-dp-singleton/</link><pubDate>Wed, 29 Mar 2017 11:36:29 +0000</pubDate><guid>/post/2017/js-dp-singleton/</guid><description>在 JavaScript 开发中，单例模式的用途非常广泛。比如，当我们单击登录按钮的时候，页面中会出现一个登录浮窗，而这个登录浮窗是唯一的，无论单击多少次登录按钮</description></item></channel></rss>